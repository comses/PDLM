{
  "example_1": "We have a module named controller that sends on and off signals to a light. The controller must send these commands after every second. The initial state of the light is off and the controller will auto-start the cycle 10 seconds after the simulation start. Once started the toggling should never end.",
  "example_2": "We have a module named controller that sends on and off signals to five identical lights. The controller must send these commands after every second. The initial state of the lights is off and the controller will auto-start the cycle 10 seconds after the simulation start. Once started the toggling should never end. Even though the light component is to be repeated five times, give the facts for each light by naming this atomic component as light1, light2, light3....",
  "example_3": "We need a controller-light coupled model that can be used as a single unit. The atomic module controller sends on and off signals to it corresponding light. The initial state of the lights is off and the controllers will auto start the cycle 10 seconds after the simulation start. Of this controller-light abstraction, create 5 pairs. Although the components are identical, generate all the coupled facts by naming them 'coupled1', 'coupled2', and so on. Similarly for the atomic components, generate controller1, controller2...., light1, light2,... Modify the controllers to have 1,2,3,4,5 seconds of frequency in generating the on and off signals.",
  "example_4": "We have five controller modules, each sending on and off signals to a single light with the frquencies of 1,2,3,4,5 seconds. The initial state of the light is off and the controllers will auto start the cycle 10 seconds after the simulation starts. Although the components are identical, generate all the atomic facts by naming them 'controller1', 'controller2',.. and so on.",
  "example_5": "We have a module named controller that sends on and off signals to a light. The controller must send these commands after every second. The initial state of the light is off and the controller will auto-start the cycle 10 seconds after the simulation start. Once started the toggling should never end. We add a sensor to this setup to know if the light is on or off.",
  "example_6": "We have a module named controller that sends on and off signals to a light. The controller must send these commands after every second. The initial state of the light is off and the controller will auto-start the cycle 10 seconds after the simulation start. Once started the toggling should never end. We add a sensor to this setup to know if the light is on or off. The sensor should send the feedback to the controller, telling it to stop toggling the light and simply turn it off. This should happen after 10 on-off light cycles, the sensor is the component responsible of knowing when that threshold is reached.",
  "example_7": "We have three controller modules, each sending on and off signals to three lights individually with the frquencies of 1,2,3 seconds. The initial state of the lights is off and the controllers will auto-start the cycle 10 seconds after the simulation start. We add a sensor to this setup to keep the track of total on-off cycles irrespective of the light. The sensor should send the feedback to all the controllers, telling them to stop toggling the light and simply turn it off. This should happen after 10 on-off light cycles are detected, the sensor is the component responsible of knowing when that threshold is reached.",
  "processor_with_queue": "We have a module named generator that sends jobs to a processor with queue. The generator must send only three jobs at 11th, 12th and 13th second once the simulation starts. The initial state of the processor is idle. Once job signal is sent to the processor, processor takes 2 clocks to process the job send it to the output port. Proceessor will maintain the state busy during proccessing and will return to idle after processing the job. The jobs that are not ready for the processing will wait in the queue until the processor comes out of busy state.",
  "multi_gen_multi_proc": "We have two generators and a processor with two input ports.\n\nGenerator_A has one output port and produces 5 jobs periodically at every 3 seconds and then goes back to idle infinitely.\n\nGenerator_B has two output ports (outport_1, and outport_2). The First output port will generate 5 jobs periodically at every 6 seconds. The second output port will generate 5 jobs periodically at every 9 seconds.\n\nProcessor will have two input ports (inport_1, and inport_2) to take in the jobs. There is a single queue which will accomodate the incoming jobs. There is no priority over the jobs coming at the particular input port to be processsed first. The processor will take 2 seconds to process a job. It will be initated in idle state and will maintain busy state while processing and will go back to idle if there are no jobs left in the queue.\n\nThe output port of the Generator_A will be connected to the inport_1 of the processor. The outport_1 of the Generator_B will be connected to the inport_1 of the processor and outport_2 of the Generator_B will be connected to the inport_2 of the processor.",
  "multi_gen_multi_proc_2": "We have two generators and a processor with two input ports.\n\nGenerator_A has one output port and produces 5 jobs periodically at every 3 seconds and then goes back to idle infinitely.\n\nGenerator_B has two output ports (outport_1, and outport_2). The jobs will be generated on both the ports at each 6 seconds periodically 5 times. Then the generator will go back to idle state infinitely.\n\nProcessor will have two input ports (inport_1, and inport_2) to take in the jobs. There is a single queue which will accomodate the incoming jobs. There is no priority over the jobs coming at the particular input port to be processsed first. The processor will take 2 seconds to process a job. It will be initated in idle state and will maintain busy state while processing and will go back to idle if there are no jobs left in the queue.\n\nThe output port of the Generator_A will be connected to the inport_1 of the processor. The outport_1 of the Generator_B will be connected to the inport_1 of the processor and outport_2 of the Generator_B will be connected to the inport_2 of the processor.",
  "multi_gen_multi_proc_w_feedback": "We have two generators, processor with two input ports and a sensor in our system.\n\nGenerator_A has one input port and one output port and produces jobs at each 3 seconds periodically till stop signal is received on the stop port. On receiving the stop signal, Generator_A will stop generating the jobs and go into the \"passive\" state.\n\nGenerator_B has has one input port stop and two output ports (out_1, and out_2). The jobs will be generated on both the ports at each 6 seconds periodically till stop signla is received. On receiving the stop signal, Generator_A will stop generating the jobs and go into the \"passive\" state.\n\nProcessor will have two input ports (in_1, and in_2) to take in the jobs. There is a single queue which will accomodate the incoming jobs. There is no priority over the jobs coming at the particular input port to be processsed first. The processor will take 2 seconds to process a job. It will be initated in idle state and will maintain busy state while processing and will go back to idle if there are no jobs left in the queue.\n\nThe sensor will receive the processed jobs from the out port of the processor. Once any 10 jobs are processed, it will generate the stop signal on out port will stop both the generators.\n\nThe out port of the Generator_A will be connected to the in_1 of the processor. The out_1 of the Generator_B will be connected to the in_1 of the processor and out_2 of the Generator_B will be connected to the in_2 of the processor. The out port of the processor will be connected to the sensor. The out port of the sensor will be connected to the in port of both Generator_A, and Generator_B.",
  "multi_gen_multi_proc_multi_out_w_feedback": "We have two generators, a processor and two sensors in our system.\n\nGenerator_A has one input port and one output port and produces jobs at each 3 seconds periodically till stop signal is received on the stop port. On receiving the stop signal, Generator_A will stop generating the jobs and go into the \"passive\" state. The generated Jobs should be like JobA1, JobA2....\n\nGenerator_B has has one input port stop and two output ports (out_1, and out_2). The jobs will be generated on both the ports at each 6 seconds periodically till stop signla is received. On receiving the stop signal, Generator_A will stop generating the jobs and go into the \"passive\" state. The generated jobs from out_1 should look like JobB11, JobB12....The generated jobs from out_2 should look like JobB21, JobB22....\n\nThe Processor will have two input ports (in_1, and in_2) and two output ports (out_1, out_2) to take in the jobs. There is a single queue which will accomodate the incoming jobs. There is no priority over the jobs coming at the particular input port to be processsed first. The processor will take 2 seconds to process a job. It will be initated in idle state and will maintain busy state while processing and will go back to idle if there are no jobs left in the queue. The jobs coming from Generator_A should go to out_1 after processing. The jobs from Generator_B should go to out_2 after processing.\n\nThe Sensor_A will receive the processed jobs from the out_1 of the processor and will keep the count. Once the 5 jobs are processed, it will generate the stop signal on out port will stop Generator_A.\n\nThe Sensor_B will receive the processed jobs from the out_2 of the processor and will keep the count. Once the 5 jobs are processed, it will generate the stop signal on out port will stop Generator_B.\n\nThe out port of the Generator_A will be connected to the in_1 of the processor. The out_1 of the Generator_B will be connected to the in_1 of the processor and out_2 of the Generator_B will be connected to the in_2 of the processor. The out_1 of the processor will be connected to the in port of Sensor_A. The out port of the Sensor_A will be connected to the in port of Generator_A. The out_2 of the processor will be connected to the in port of Sensor_B. The out port of the Sensor_B will be connected to the in port of Generator_B.",
  "single_gen_single_proc_single_sensor_w_feedback_multi_hir": "We have one Generator atomic model and one Processor-Sensor coupled model that form a hierarchical system model. This system model has three levels.\n\nProcessor-Sensor Coupled model:\n\nThe Processor and Sensor form one coupled model. \n\nThe Processor will have one input port (in_1) and one output port (out_1). There is a queue which will accomodate the incoming jobs. The processor will take 2 seconds to process a job. It will be initated in idle state and will maintain busy state while processing and will go back to idle if there are no jobs left in the queue.\n\nThe Sensor will receive the processed jobs from the out_1 of the processor and will keep the count. Once the 5 jobs are processed, it will generate the stop signal on out port will stop Generator. \n\nThe in port of Processor-Sensor Coupled model will be connected to the in_1 of Processor. The out_1 of the Processor will be connected to the in port of Sensor. The out port of the Sensor will be connected to the out port of the Processor-Sensor Coupled Model.\n\nOverall System:\n\nGenerator has one input port (stop) and one output port (out) and produces jobs at each 3 seconds periodically till stop signal is received on the stop port. On receiving the stop signal, Generator_A will stop generating the jobs and go into the \"passive\" state. The generated Jobs should be like Job1, Job2, Job3....\n\nThe out port of the Generator will be connected to the in port of Processor-Sensor Coupled Model. The out port of the Processor-Sensor coupled model will be connected to the Generator in port. Provide the Processor-Sensor Coupled model first and then the overall system."
}